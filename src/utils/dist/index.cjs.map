{"version":3,"sources":["../src/constants/common.ts","../src/helpers/notifier.ts","../src/helpers/common.ts","../src/events/errorEvents.ts","../src/events/baseEvents.ts","../src/events/audioEvents.ts","../src/events/listeners.ts","../src/mediasession/mediasessionHandler.ts","../src/states/audioState.ts","../src/audio.ts"],"names":["AUDIO_X_CONSTANTS","Object","freeze","REACT","VANILLA","DEVELOPMENT","PLAYBACK_STATE","BUFFERING","PLAYING","PAUSED","READY","IDLE","ENDED","STALLED","ERROR","ERROR_MSG_MAP","MEDIA_ERR_ABORTED","MEDIA_ERR_DECODE","MEDIA_ERR_NETWORK","MEDIA_ERR_SRC_NOT_SUPPORTED","DEFAULT","_a","ChangeNotifier","validateEventName","eventName","Error","notify","data","caller","listenerCbs","listeners","notifierState","forEach","cb","listen","callback","state","add","Set","eventListeners","delete","size","multiListen","callbacks","Array","isArray","length","unsubscribeFunctions","map","unsubscribe","getLatestState","__publicField","notifier_default","isValidArray","__name","arr","isValidWindow","window","undefined","Window","getReadableErrorMessage","audioInstance","message","error","code","MediaError","metaDataCreator","mediaTrack","title","album","artist","artwork","artworkUrl","src","artworkMap","el","sizes","type","previousTrackPlayTime","calculateActualPlayedLength","event","lengthSet","i","played","startX","start","width","end","currentTrackPlayTime","reduce","acc","val","ERROR_EVENTS","notifier","BASE_EVENT_CALLBACK_MAP","LOADED_META_DATA","e","playLogEnabled","playbackState","duration","readable","CAN_PLAY","CAN_PLAY_THROUGH","PLAY","progress","currentTime","PAUSE","errorCode","TIME_UPDATE","paused","WAITING","VOLUME_CHANGE","AUDIO_EVENTS","ABORT","DURATION_CHANGE","EMPTIED","SEEKING","SEEKED","LOADED_DATA","RATE_CHANGE","SUSPEND","PROGRESS","LOAD_START","CUSTOM_AUDIO_EVENTS","AUDIO_X_STATE","attachDefaultEventListeners","eventListenersCallbackMap","AudioX","getAudioInstance","keys","evt","addEventListener","listenerCallback","attachCustomEventListeners","eventListenersList","enablePlayLog","includes","updateMetaData","navigator","mediaSession","metadata","MediaMetadata","attachMediaSessionHandlers","setActionHandler","play","pause","READY_STATE","HAVE_NOTHING","HAVE_METADATA","HAVE_CURRENT_DATA","HAVE_FUTURE_DATA","HAVE_ENOUGH_DATA","AUDIO_STATE","bufferedDuration","volume","playbackRate","currentTrack","constructor","_audio","_instance","process","env","NODE_ENV","Audio","init","initProps","preloadStrategy","autoplay","useDefaultEventListeners","customEventListeners","showNotificationActions","setAttribute","preload","addMedia","source","load","isSourceAvailable","addMediaAndPlay","then","setTimeout","stop","reset","srcObject","setVolume","actualVolume","setPlaybackRate","mute","muted","seek","time","destroy","removeAttribute","subscribe","attachEventListeners","id","getAttribute","media"],"mappings":"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","sourcesContent":["import { InitMode } from 'types';\nimport { ErrorMessageMap } from 'types/errorEvents.types';\n\nconst AUDIO_X_CONSTANTS = Object.freeze({\n  REACT: 'REACT' as InitMode,\n  VANILLA: 'VANILLA' as InitMode,\n  DEVELOPMENT: 'development'\n});\n\nconst PLAYBACK_STATE = Object.freeze({\n  BUFFERING: 'buffering',\n  PLAYING: 'playing',\n  PAUSED: 'paused',\n  READY: 'ready',\n  IDLE: 'idle',\n  ENDED: 'ended',\n  STALLED: 'stalled',\n  ERROR: 'error'\n});\n\nconst ERROR_MSG_MAP: ErrorMessageMap = Object.freeze({\n  MEDIA_ERR_ABORTED: 'The user canceled the audio.',\n  MEDIA_ERR_DECODE: 'An error occurred while decoding the audio.',\n  MEDIA_ERR_NETWORK: 'A network error occurred while fetching the audio.',\n  MEDIA_ERR_SRC_NOT_SUPPORTED:\n    'The audio is missing or is in a format not supported by your browser.',\n  DEFAULT: 'An unknown error occurred.'\n});\n\nexport { AUDIO_X_CONSTANTS, ERROR_MSG_MAP, PLAYBACK_STATE };\n","type ListenerCallback<T> = (data: T) => void;\n\nclass ChangeNotifier {\n  private static listeners: Record<string, Set<ListenerCallback<any>>> = {};\n  private static notifierState: Record<string, any> = {};\n\n  private static validateEventName(eventName: string): void {\n    if (!eventName || typeof eventName !== 'string') {\n      throw new Error('Invalid event name');\n    }\n  }\n\n  static notify<T>(\n    eventName: string,\n    data: T,\n    caller: string = 'audiox_notifier_default'\n  ): void {\n    this.validateEventName(eventName);\n\n    const listenerCbs = ChangeNotifier.listeners[eventName];\n\n    if (!listenerCbs) return;\n\n    if (data !== null) {\n      console.log(`NOTIFYING TO EVENT : ${eventName} - CALLER : ${caller}`);\n\n      ChangeNotifier.notifierState[eventName] = {\n        ...(ChangeNotifier.notifierState[eventName] || {}),\n        ...data\n      };\n\n      listenerCbs.forEach((cb: ListenerCallback<any>) => {\n        cb(ChangeNotifier.notifierState[eventName]);\n      });\n    }\n  }\n\n  static listen<T>(\n    eventName: string,\n    callback: ListenerCallback<T>,\n    state = {}\n  ): () => void {\n    this.validateEventName(eventName);\n\n    if (typeof callback !== 'function') {\n      throw new Error('Callback must be a function');\n    }\n\n    if (!ChangeNotifier.listeners[eventName]) {\n      ChangeNotifier.notifierState[eventName] = state;\n      ChangeNotifier.listeners[eventName] = new Set([callback]);\n    } else {\n      ChangeNotifier.listeners[eventName].add(callback);\n    }\n\n    return (): void => {\n      const eventListeners = ChangeNotifier.listeners[eventName];\n\n      if (!eventListeners) {\n        console.log(`EVENT NOT FOUND : ${eventName}`);\n        return;\n      }\n\n      console.log(`REMOVING EVENT LISTENER FOR EVENT : ${eventName}`);\n\n      eventListeners.delete(callback);\n\n      if (eventListeners.size === 0) {\n        delete ChangeNotifier.listeners[eventName];\n      }\n    };\n  }\n\n  static multiListen<T>(\n    eventName: string,\n    callbacks: ListenerCallback<T>[],\n    state = {}\n  ): () => void {\n    this.validateEventName(eventName);\n\n    if (!Array.isArray(callbacks) || callbacks.length === 0) {\n      throw new Error('Callbacks must be a non-empty array of functions');\n    }\n\n    const unsubscribeFunctions = callbacks.map((callback) =>\n      ChangeNotifier.listen(eventName, callback, state)\n    );\n\n    return (): void => {\n      unsubscribeFunctions.forEach((unsubscribe) => unsubscribe());\n    };\n  }\n\n  // Retrieve the latest state data for a specific event\n  static getLatestState<T>(eventName: string): T | undefined {\n    this.validateEventName(eventName);\n\n    return ChangeNotifier.notifierState[eventName];\n  }\n}\n\nexport default ChangeNotifier;\n","import { ERROR_MSG_MAP } from 'constants/common';\nimport { AudioEvents, MediaTrack } from 'types';\nimport ChangeNotifier from './notifier';\n\nconst isValidArray = (arr: any[]) => arr && Array.isArray(arr) && arr.length;\nconst isValidFunction = (fn: any) =>\n  fn instanceof Function && typeof fn === 'function';\n\nconst isValidObject = (obj: any) =>\n  typeof obj === 'object' &&\n  obj !== null &&\n  obj instanceof Object &&\n  Object.keys(obj).length;\n\nconst isValidWindow = typeof window !== undefined && window instanceof Window;\n\nconst getReadableErrorMessage = (audioInstance: HTMLAudioElement) => {\n  let message = '';\n  const err = audioInstance.error;\n\n  switch (err?.code) {\n    case MediaError.MEDIA_ERR_ABORTED:\n      message += ERROR_MSG_MAP['MEDIA_ERR_ABORTED'];\n      break;\n    case MediaError.MEDIA_ERR_NETWORK:\n      message += ERROR_MSG_MAP['MEDIA_ERR_NETWORK'];\n      break;\n    case MediaError.MEDIA_ERR_DECODE:\n      message += ERROR_MSG_MAP['MEDIA_ERR_DECODE'];\n      break;\n    case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:\n      message += ERROR_MSG_MAP['MEDIA_ERR_SRC_NOT_SUPPORTED'];\n      break;\n    default:\n      message += ERROR_MSG_MAP['DEFAULT'];\n      break;\n  }\n\n  return message;\n};\n\nconst metaDataCreator = (mediaTrack: MediaTrack) => {\n  const { title, album, artist, artwork } = mediaTrack;\n  const artworkUrl = artwork ? artwork[0]?.src : '';\n  const sizes = [\n    '96x96',\n    '128x128',\n    '192x192',\n    '256x256',\n    '384x384',\n    '512x512'\n  ];\n  const artworkMap = sizes.map((el) => {\n    return { src: artworkUrl, sizes: el, type: 'image/png' };\n  });\n  const metaData = {\n    title,\n    album,\n    artist,\n    artwork: artworkMap\n  };\n  return metaData;\n};\n\nlet previousTrackPlayTime = 0;\nexport const calculateActualPlayedLength = (\n  audioInstance: HTMLAudioElement,\n  event?: keyof AudioEvents\n) => {\n  const lengthSet = new Set();\n  for (let i = 0; i < audioInstance.played.length; i++) {\n    const startX = audioInstance.played.start(i);\n    const endX = audioInstance.played.end(i);\n    const width = endX - startX;\n    lengthSet.add(width);\n  }\n  const lengthArr = [...lengthSet] as number[];\n  const currentTrackPlayTime = lengthArr.reduce((acc, val) => acc + val, 0);\n  previousTrackPlayTime =\n    event === 'ENDED' ? currentTrackPlayTime : previousTrackPlayTime;\n  ChangeNotifier.notify('AUDIO_STATE', {\n    currentTrackPlayTime,\n    previousTrackPlayTime\n  });\n};\n\nexport {\n  getReadableErrorMessage,\n  isValidArray,\n  isValidFunction,\n  isValidObject,\n  isValidWindow,\n  metaDataCreator\n};\n","import { ErrorEvents } from 'types/errorEvents.types';\n\nexport const ERROR_EVENTS: ErrorEvents = Object.freeze({\n  1: 'MEDIA_ERR_ABORTED',\n  3: 'MEDIA_ERR_DECODE',\n  2: 'MEDIA_ERR_NETWORK',\n  4: 'MEDIA_ERR_SRC_NOT_SUPPORTED',\n});\n","import { PLAYBACK_STATE } from 'constants/common';\nimport {\n  calculateActualPlayedLength,\n  getReadableErrorMessage\n} from 'helpers/common';\nimport ChangeNotifier from 'helpers/notifier';\nimport { EventListenerCallbackMap } from 'types';\nimport { ERROR_EVENTS } from './errorEvents';\nconst notifier = ChangeNotifier;\n\nconst BASE_EVENT_CALLBACK_MAP: EventListenerCallbackMap = {\n  LOADED_META_DATA: (\n    e: Event,\n    audioInstance: HTMLAudioElement,\n    playLogEnabled\n  ) => {\n    console.log('STATUS', e.type);\n    notifier.notify(\n      'AUDIO_STATE',\n      {\n        playbackState: PLAYBACK_STATE.BUFFERING,\n        duration: audioInstance?.duration,\n        error: { code: null, message: '', readable: '' }\n      },\n      `audiox_baseEvents_state_state_${e.type}`\n    );\n    if (playLogEnabled) {\n      calculateActualPlayedLength(audioInstance, 'PAUSE');\n    }\n  },\n\n  CAN_PLAY: (e: Event, audioInstance, playLogEnabled) => {\n    console.log('STATUS', e.type);\n\n    notifier.notify(\n      'AUDIO_STATE',\n      {\n        playbackState: PLAYBACK_STATE.BUFFERING,\n        error: { code: null, message: '', readable: '' }\n      },\n      `audiox_baseEvents_state_${e.type}`\n    );\n    if (playLogEnabled) {\n      calculateActualPlayedLength(audioInstance, 'PAUSE');\n    }\n  },\n\n  CAN_PLAY_THROUGH: (e: Event, audioInstance, playLogEnabled) => {\n    console.log('STATUS', e.type);\n\n    notifier.notify(\n      'AUDIO_STATE',\n      {\n        playbackState: PLAYBACK_STATE.READY,\n        error: { code: null, message: '', readable: '' }\n      },\n      `audiox_baseEvents_state_${e.type}`\n    );\n    if (playLogEnabled) {\n      calculateActualPlayedLength(audioInstance, 'PAUSE');\n    }\n  },\n\n  PLAY: (e: Event, audioInstance: HTMLAudioElement) => {\n    console.log('STATUS', e.type);\n    notifier.notify(\n      'AUDIO_STATE',\n      {\n        playbackState: PLAYBACK_STATE.PLAYING,\n        progress: audioInstance?.currentTime,\n        error: { code: null, message: '', readable: '' }\n      },\n      `audiox_baseEvents_state_${e.type}`\n    );\n  },\n\n  PAUSE: (e: Event, audioInstance: HTMLAudioElement, playLogEnabled) => {\n    console.log('STATUS', e.type);\n    notifier.notify(\n      'AUDIO_STATE',\n      {\n        playbackState: PLAYBACK_STATE.PAUSED,\n        progress: audioInstance?.currentTime,\n        error: { code: null, message: '', readable: '' }\n      },\n      `audiox_baseEvents_state_${e.type}`\n    );\n    if (playLogEnabled) {\n      calculateActualPlayedLength(audioInstance, 'PAUSE');\n    }\n  },\n\n  ENDED: (e: Event, audioInstance: HTMLAudioElement, playLogEnabled) => {\n    console.log('STATUS', e.type);\n    notifier.notify(\n      'AUDIO_STATE',\n      {\n        playbackState: PLAYBACK_STATE.ENDED,\n        progress: audioInstance?.currentTime,\n        error: { code: null, message: '', readable: '' }\n      },\n      `audiox_baseEvents_state_${e.type}`\n    );\n    if (playLogEnabled) {\n      calculateActualPlayedLength(audioInstance, 'ENDED');\n    }\n  },\n\n  ERROR: (e: Event, audioInstance: HTMLAudioElement, playLogEnabled) => {\n    console.log('STATUS', e.type);\n    const errorCode = audioInstance.error?.code as keyof typeof ERROR_EVENTS;\n    const message = getReadableErrorMessage(audioInstance);\n    notifier.notify(\n      'AUDIO_STATE',\n      {\n        playbackState: PLAYBACK_STATE.PAUSED,\n        error: {\n          code: errorCode,\n          message: ERROR_EVENTS[errorCode],\n          readable: message\n        }\n      },\n      `audiox_baseEvents_state_${e.type}`\n    );\n    if (playLogEnabled) {\n      calculateActualPlayedLength(audioInstance, 'ERROR');\n    }\n  },\n\n  TIME_UPDATE: (e: Event, audioInstance: HTMLAudioElement) => {\n    notifier.notify(\n      'AUDIO_STATE',\n      {\n        playbackState: audioInstance.paused\n          ? PLAYBACK_STATE.IDLE\n          : PLAYBACK_STATE.PLAYING,\n        progress: audioInstance?.currentTime,\n        error: { code: null, message: '', readable: '' }\n      },\n      `audiox_baseEvents_state_${e.type}`\n    );\n  },\n\n  WAITING: (e: Event, audioInstance: HTMLAudioElement) => {\n    console.log('STATUS', e.type);\n    notifier.notify(\n      'AUDIO_STATE',\n      {\n        playbackState: PLAYBACK_STATE.BUFFERING,\n        progress: audioInstance?.currentTime,\n        error: { code: null, message: '', readable: '' }\n      },\n      `audiox_baseEvents_state_${e.type}`\n    );\n  },\n\n  VOLUME_CHANGE: (e: Event) => {\n    console.log('STATUS', e.type);\n    notifier.notify('AUDIO_STATE', {}, `audiox_baseEvents_state`);\n  }\n};\n\nexport { BASE_EVENT_CALLBACK_MAP };\n","import { AudioEvents } from 'types';\n\nexport const AUDIO_EVENTS: AudioEvents = Object.freeze({\n  ABORT: 'abort',\n  TIME_UPDATE: 'timeupdate',\n  CAN_PLAY: 'canplay',\n  CAN_PLAY_THROUGH: 'canplaythrough',\n  DURATION_CHANGE: 'durationchange',\n  ENDED: 'ended',\n  EMPTIED: 'emptied',\n  PLAYING: 'playing',\n  WAITING: 'waiting',\n  SEEKING: 'seeking',\n  SEEKED: 'seeked',\n  LOADED_META_DATA: 'loadedmetadata',\n  LOADED_DATA: 'loadeddata',\n  PLAY: 'play',\n  PAUSE: 'pause',\n  RATE_CHANGE: 'ratechange',\n  VOLUME_CHANGE: 'volumechange',\n  SUSPEND: 'suspend',\n  STALLED: 'stalled',\n  PROGRESS: 'progress',\n  LOAD_START: 'loadstart',\n  ERROR: 'error',\n});\n\nexport const CUSTOM_AUDIO_EVENTS = Object.freeze({\n  AUDIO_X_STATE: 'AUDIO_X_STATE',\n});\n","import { AudioX } from 'audio';\nimport { isValidArray } from 'helpers/common';\nimport ChangeNotifier from 'helpers/notifier';\nimport {\n  AudioEvents,\n  EventListenerCallbackMap,\n  EventListenersList\n} from 'types/audioEvents.types';\nimport { AUDIO_EVENTS } from './audioEvents';\n\n/**\n * this attaches event listeners, for audio also sends a flag to calculate playLog\n * loops through the event listeners map and attaches it to the audio element\n */\nconst attachDefaultEventListeners = (\n  eventListenersCallbackMap: EventListenerCallbackMap,\n  playLogEnabled: boolean = false\n) => {\n  const audioInstance = AudioX.getAudioInstance();\n  isValidArray(Object.keys(eventListenersCallbackMap)) &&\n    Object.keys(eventListenersCallbackMap).forEach((evt) => {\n      let event = evt as keyof AudioEvents;\n      audioInstance?.addEventListener(AUDIO_EVENTS[event], (e: Event) => {\n        if (evt && eventListenersCallbackMap[event]) {\n          const listenerCallback = eventListenersCallbackMap[event];\n          if (typeof listenerCallback === 'function') {\n            listenerCallback(e, audioInstance, playLogEnabled);\n          }\n        }\n      });\n    });\n};\n\nconst attachCustomEventListeners = (\n  eventListenersList: EventListenersList,\n  enablePlayLog: boolean = false\n) => {\n  const audioInstance = AudioX.getAudioInstance();\n  if (isValidArray(eventListenersList)) {\n    eventListenersList.forEach((evt) => {\n      let event = evt as keyof AudioEvents;\n      if (Object.keys(AUDIO_EVENTS).includes(event)) {\n        audioInstance?.addEventListener(AUDIO_EVENTS[event], (e: Event) => {\n          ChangeNotifier.notify(AUDIO_EVENTS[event], {\n            e,\n            audioInstance,\n            enablePlayLog\n          });\n        });\n      }\n    });\n  }\n};\n\nexport { attachCustomEventListeners, attachDefaultEventListeners };\n","import { AudioX } from 'audio';\nimport { metaDataCreator } from 'helpers/common';\nimport ChangeNotifier from 'helpers/notifier';\nimport { AudioState } from 'types';\n\nexport const updateMetaData = (data: any) => {\n  if ('mediaSession' in navigator) {\n    navigator.mediaSession.metadata = new MediaMetadata(metaDataCreator(data));\n  }\n};\n\nexport const attachMediaSessionHandlers = () => {\n  if ('mediaSession' in navigator) {\n    navigator.mediaSession.setActionHandler('play', () => {\n      const audioInstance = AudioX.getAudioInstance();\n\n      audioInstance.play();\n    });\n    navigator.mediaSession.setActionHandler('pause', () => {\n      const audioInstance = AudioX.getAudioInstance();\n      audioInstance.pause();\n    });\n  }\n};\n\nexport const updatePositionState = () => {\n  ChangeNotifier.listen('AUDIO_X_STATE', (data: AudioState) => {\n    if (data?.duration && data?.playbackRate && data?.progress) {\n      navigator.mediaSession.setPositionState({\n        duration: data.duration,\n        playbackRate: data.playbackRate,\n        position: data.progress\n      });\n    }\n  });\n};\n","import { PLAYBACK_STATE } from 'constants/common';\nimport ChangeNotifier from 'helpers/notifier';\nimport { ReadyState } from 'types';\nimport { AudioState, MediaTrack } from 'types/audio.types';\n\nexport const READY_STATE: ReadyState = {\n  HAVE_NOTHING: 0,\n  HAVE_METADATA: 1,\n  HAVE_CURRENT_DATA: 2,\n  HAVE_FUTURE_DATA: 3,\n  HAVE_ENOUGH_DATA: 4\n};\n\nexport const AUDIO_STATE: AudioState = {\n  playbackState: PLAYBACK_STATE.IDLE,\n  duration: 0,\n  bufferedDuration: 0,\n  progress: 0,\n  volume: 50,\n  playbackRate: 1,\n  error: {\n    code: null,\n    message: '',\n    readable: ''\n  },\n  currentTrack: {} as MediaTrack,\n  currentTrackPlayTime: 0,\n  previousTrackPlayTime: 0\n};\n\n/* Listen to state changes and update global audio state that is being exposed to outer world\n  Do not subscribe to this event, this may cause unexpected behavior instead attach your own custom\n  event listener, if you wish to have granular control on audio state. See: attachCustomEventListener \n*/\nChangeNotifier.listen(\n  'AUDIO_STATE',\n  (data: AudioState) => {\n    ChangeNotifier.notify('AUDIO_X_STATE', { ...AUDIO_STATE, ...data });\n  },\n  AUDIO_STATE\n);\n","import { AUDIO_X_CONSTANTS } from 'constants/common';\nimport { BASE_EVENT_CALLBACK_MAP } from 'events/baseEvents';\nimport {\n  attachCustomEventListeners,\n  attachDefaultEventListeners\n} from 'events/listeners';\nimport { calculateActualPlayedLength } from 'helpers/common';\nimport ChangeNotifier from 'helpers/notifier';\nimport {\n  attachMediaSessionHandlers,\n  updateMetaData\n} from 'mediasession/mediasessionHandler';\nimport { AUDIO_STATE, READY_STATE } from 'states/audioState';\nimport { EventListenersList } from 'types';\nimport { AudioInit, MediaTrack, PlaybackRate } from 'types/audio.types';\n\nlet audioInstance: HTMLAudioElement;\nconst notifier = ChangeNotifier;\n\nclass AudioX {\n  private _audio: HTMLAudioElement;\n  private static _instance: AudioX;\n\n  constructor() {\n    if (AudioX._instance) {\n      console.warn(\n        'Instantiation failed: cannot create multiple instance of AudioX returning existing instance'\n      );\n      return AudioX._instance;\n    }\n    if (\n      process.env.NODE_ENV !== AUDIO_X_CONSTANTS?.DEVELOPMENT &&\n      audioInstance\n    ) {\n      throw new Error('Cannot create multiple audio instance');\n    }\n\n    AudioX._instance = this;\n    this._audio = new Audio();\n  }\n\n  /**\n   *\n   * @param initProps  initial config to initialize AudioX\n   * @param initProps.mediaTrack mediaTrack Object containing metadata and source of the media\n   * @param initProps.mediaTrack.title title of the Audio\n   * @param initProps.mediaTrack.source URI of the Audio\n   * @param initProps.mediaTrack.artwork artwork of the Audio\n   * @param initProps.mediaTrack.duration  duration of the audio\n   * @param initProps.mediaTrack.genre genre of the audio\n   * @param initProps.mediaTrack.album album of the audio\n   * @param initProps.mediaTrack.comment comment for the audio\n   * @param initProps.mediaTrack.year release year of the audio\n   * @param initProps.mediaTrack.artist artist of the audio\n   * @param mode mode of operation for AudioX\n   * @param autoplay flag for autoplay\n   * @param preloadStrategy strategy for preloading audio\n   * @param playbackRate default playbackRate of the audio\n   * @param attachAudioEventListeners flag for registering audio events\n   * @param attachMediaSessionHandlers flag for registering mediaSession handlers\n   */\n\n  async init(initProps: AudioInit) {\n    const {\n      preloadStrategy = 'auto',\n      autoplay = false,\n      useDefaultEventListeners = true,\n      customEventListeners = null,\n      showNotificationActions = false,\n      enablePlayLog = false\n    } = initProps;\n\n    this._audio?.setAttribute('id', 'audio_x_instance');\n    this._audio.preload = preloadStrategy;\n    this._audio.autoplay = autoplay;\n    audioInstance = this._audio;\n\n    if (useDefaultEventListeners || customEventListeners == null) {\n      attachDefaultEventListeners(BASE_EVENT_CALLBACK_MAP, enablePlayLog);\n    }\n\n    if (showNotificationActions) {\n      attachMediaSessionHandlers();\n    }\n  }\n\n  async addMedia(mediaTrack: MediaTrack) {\n    if (mediaTrack) {\n      audioInstance.src = mediaTrack.source;\n      notifier.notify('AUDIO_STATE', {\n        ...AUDIO_STATE,\n        currentTrack: mediaTrack\n      });\n      updateMetaData(mediaTrack);\n      audioInstance.load();\n    }\n  }\n\n  async play() {\n    const isSourceAvailable = audioInstance.src !== '';\n    if (\n      audioInstance?.paused &&\n      audioInstance.HAVE_ENOUGH_DATA === READY_STATE.HAVE_ENOUGH_DATA &&\n      isSourceAvailable\n    ) {\n      await audioInstance.play();\n    }\n  }\n\n  /**\n   *\n   * @param mediaTrack MediaTrack to be added and played\n   *\n   * Note: Use this method when you want to add media and do playback or want continuous playback\n   * You can also call addMedia and Play Separately to achieve playback.\n   */\n\n  async addMediaAndPlay(mediaTrack: MediaTrack) {\n    if (mediaTrack) {\n      this.addMedia(mediaTrack).then(() => {\n        if (audioInstance.HAVE_ENOUGH_DATA === READY_STATE.HAVE_ENOUGH_DATA) {\n          setTimeout(async () => {\n            await this.play();\n          }, 950);\n        }\n      });\n    }\n  }\n\n  pause() {\n    if (audioInstance && !audioInstance?.paused) {\n      audioInstance?.pause();\n    }\n  }\n\n  stop() {\n    if (audioInstance && !audioInstance.paused) {\n      audioInstance?.pause();\n      audioInstance.currentTime = 0;\n    }\n  }\n\n  /**\n   * @method reset :  This stops the playback and resets all the state of the audio\n   */\n  async reset() {\n    if (audioInstance) {\n      this.stop();\n      audioInstance.src = '';\n      audioInstance.srcObject = null;\n    }\n  }\n\n  /**\n   * @param volume : numeric value between 1-100 to be used.\n   */\n  setVolume(volume: number) {\n    const actualVolume = volume / 100;\n    if (audioInstance) {\n      audioInstance.volume = actualVolume;\n      notifier.notify('AUDIO_STATE', {\n        ...AUDIO_STATE,\n        volume: volume\n      });\n    }\n  }\n  /**\n   * @param playbackRate : a number denoting speed at which the playback should happen,\n   */\n  setPlaybackRate(playbackRate: PlaybackRate) {\n    if (audioInstance) {\n      audioInstance.playbackRate = playbackRate;\n      notifier.notify('AUDIO_STATE', {\n        ...AUDIO_STATE,\n        playbackRate\n      });\n    }\n  }\n\n  mute() {\n    if (audioInstance && !audioInstance.muted) {\n      audioInstance.muted = true;\n    }\n  }\n\n  seek(time: number) {\n    if (audioInstance) {\n      audioInstance.currentTime = time;\n    }\n  }\n\n  async destroy() {\n    if (audioInstance) {\n      await this.reset();\n      audioInstance.removeAttribute('src');\n      audioInstance.load();\n    }\n  }\n\n  subscribe(eventName: string, callback: (data: any) => void, state: any = {}) {\n    const unsubscribe = notifier.listen(eventName, callback, state);\n    return unsubscribe;\n  }\n\n  attachEventListeners(eventListenersList: EventListenersList) {\n    attachCustomEventListeners(eventListenersList);\n  }\n\n  enablePlayLog() {\n    calculateActualPlayedLength(audioInstance);\n  }\n\n  get id() {\n    return audioInstance?.getAttribute('id');\n  }\n\n  set media(media: MediaTrack) {\n    if (audioInstance) {\n      audioInstance.src = media?.source;\n    }\n    // TODO: implementation metadata\n  }\n\n  static getAudioInstance() {\n    return audioInstance;\n  }\n}\n\nexport { AudioX };\n"]}